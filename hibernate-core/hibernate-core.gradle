/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
import org.apache.tools.ant.filters.ReplaceTokens
import java.io.File

plugins {
    id 'org.hibernate.build.xjc-jakarta'
}

description = 'Hibernate\'s core ORM functionality'

apply from: rootProject.file( 'gradle/published-java-module.gradle' )
apply plugin: 'org.hibernate.orm.antlr'
apply plugin: 'org.hibernate.matrix-test'


// BEGIN: For NUODB
println "hibernate-core: Using NuoDB Dialect V${nuodbHibernateJarVersion}"
// END: For NUODB

configurations {
    tests {
        description = 'Configuration for the produced test jar'
    }
}

// BEGIN: For NUODB
// Look for our JAR locally
repositories {
    mavenCentral()
    mavenLocal()
}
// END: For NUODB

dependencies {
    api jakartaLibs.jpa
    api jakartaLibs.jta

    implementation libs.hcann
    implementation libs.jandex
    implementation libs.classmate
    implementation libs.byteBuddy

    implementation jakartaLibs.jaxbApi
    implementation jakartaLibs.jaxb
    implementation jakartaLibs.inject

    implementation libs.antlrRuntime

    //implementation( "com.nuodb.hibernate:nuodb-hibernate:${nuodbHibernateJarVersion}" )
 
    compileOnly jakartaLibs.jacc
    compileOnly jakartaLibs.validation
    compileOnly jakartaLibs.cdi
    compileOnly jakartaLibs.jsonbApi
    compileOnly libs.jackson
    compileOnly libs.jacksonXml

    testImplementation project(':hibernate-testing')
    testImplementation project(':hibernate-ant')
    testImplementation testLibs.shrinkwrapApi
    testImplementation testLibs.shrinkwrap
    testImplementation testLibs.shrinkwrapDescriptors
    testImplementation testLibs.shrinkwrapDescriptorsApi
    testImplementation jakartaLibs.cdi
    testImplementation jakartaLibs.jacc
    testImplementation jakartaLibs.validation
    testImplementation jakartaLibs.el
    testImplementation( libs.validator ) {
        // for test runtime
        transitive = true
    }
    testImplementation "joda-time:joda-time:2.3"

    testImplementation    'com.nuodb.jdbc:nuodb-jdbc:24.1.1'
    testImplementation    "com.nuodb.hibernate:nuodb-hibernate:${nuodbHibernateJarVersion}"

    testRuntimeOnly libs.byteBuddy
    testRuntimeOnly testLibs.weld
    testRuntimeOnly testLibs.wildFlyTxnClient
    testRuntimeOnly libs.jackson

    testAnnotationProcessor project( ':hibernate-jpamodelgen' )

    // NOTE: it seems like, since 4.10, the Antlr Tool no longer defines
    // transitive dep on the corresponding Antlr Runtime.  At least, I get
    // errors about mismatched versions if I do not include the runtime
    // dependency here.
    antlr libs.antlr
    antlr libs.antlrRuntime

    xjc jakartaLibs.xjc
    xjc jakartaLibs.jaxb
    xjc rootProject.fileTree(dir: 'patched-libs/jaxb2-basics', include: '*.jar')
}

jar {
    manifest {
        attributes(
                'Main-Class': 'org.hibernate.Version'
        )
    }
}

ext {
    jaxbTargetDir = project.file( "${buildDir}/generated/sources/xjc/main" )
}

sourceSets {
    main {
        // add the XJC generated JAXB classes to the main source-set
        java{
            srcDir project.jaxbTargetDir
        }
    }

    // resources inherently exclude sources
    test {
        resources {
            srcDir 'src/test/java'
            srcDir 'src/test/resources'
            srcDir 'src/test/bundles'
        }
    }
}

xjc {
    outputDirectory = project.jaxbTargetDir

    schemas {
        cfg {
            xsdFile = 'src/main/resources/org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd'
            xjcBindingFile = 'src/main/xjb/hbm-configuration-bindings.xjb'
        }
        hbm {
            xsdFile = file( 'src/main/resources/org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd' )
            xjcBindingFile = file( 'src/main/xjb/hbm-mapping-bindings.xjb' )
            xjcExtensions += ['inheritance', 'simplify']
        }
        mapping {
            xsdFile = file( 'src/main/resources/org/hibernate/xsd/mapping/mapping-3.1.0.xsd' )
            xjcBindingFile = file( 'src/main/xjb/mapping-bindings.xjb' )
            xjcExtensions += ['inheritance', 'simplify']
        }
    }
}

task copyBundleResourcesXml (type: Copy) {
    inputs.property( "db", db )
    inputs.property( "dbHost", dbHost )
    ext {
        bundlesTargetDir = file( "${buildDir}/bundles" )
        // Escape
        bundleTokens = [
                'db.dialect' : dbBundle[db]['db.dialect'].replace("&", "&amp;"),
                'jdbc.driver' : dbBundle[db]['jdbc.driver'].replace("&", "&amp;"),
                'jdbc.user' : dbBundle[db]['jdbc.user'].replace("&", "&amp;"),
                'jdbc.pass' : dbBundle[db]['jdbc.pass'].replace("&", "&amp;"),
                'jdbc.url' : dbBundle[db]['jdbc.url'].replace("&", "&amp;"),
                'connection.init_sql' : dbBundle[db]['connection.init_sql'].replace("&", "&amp;")
        ]
        ext.bundleTokens['buildDirName'] = project.relativePath( buildDir )
    }

    from('src/test/bundles/templates') {
        include '**/*.xml'
    }
    into ext.bundlesTargetDir
    filter( ReplaceTokens, tokens: ext.bundleTokens)

    doFirst {
        ext.bundlesTargetDir.mkdirs()
    }
}

task copyBundleResourcesNonXml (type: Copy) {
    inputs.property( "db", db )
    ext {
        bundlesTargetDir = file( "${buildDir}/bundles" )
        // Escape
        bundleTokens = dbBundle[db]
        ext.bundleTokens['buildDirName'] = project.relativePath( buildDir )
    }

    from('src/test/bundles/templates') {
        exclude '**/*.xml'
    }
    into ext.bundlesTargetDir
    filter( ReplaceTokens, tokens: ext.bundleTokens)

    doFirst {
        ext.bundlesTargetDir.mkdirs()
    }
}

task copyBundleResources (type: Copy) {
    inputs.property( "db", db )
    dependsOn tasks.copyBundleResourcesXml
    dependsOn tasks.copyBundleResourcesNonXml
}

processTestResources {
    dependsOn copyBundleResources
    duplicatesStrategy = DuplicatesStrategy.WARN
}

sourcesJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

}

task testJar(type: Jar, dependsOn: testClasses) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveClassifier.set( 'test' )
    from sourceSets.test.output
}

artifacts {
    tests testJar
}

task generateEnversStaticMetamodel(
        type: JavaCompile,
        description: "Generate the Hibernate Envers revision entity static metamodel classes." ) {
    source = sourceSets.main.java
    // we only want to include these specific classes for metamodel generation.
    // if envers adds any additional revision entity classes, they must be listed here.
    include 'org/hibernate/envers/DefaultRevisionEntity.java'
    include 'org/hibernate/envers/DefaultTrackingModifiedEntitiesRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdTrackingModifiedEntitiesRevisionEntity.java'

    classpath = sourceSets.main.runtimeClasspath + sourceSets.test.compileClasspath
    options.compilerArgs = [
            "-proc:only",
            "-processor",
            "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"
    ]

    // put static metamodel classes back out to the source tree since they're version controlled.
    destinationDirectory = new File( "${projectDir}/src/main/java" )
}

tasks.withType( Test.class ).each { test ->
    test.systemProperty 'file.encoding', 'utf-8'

    // See org.hibernate.boot.model.naming.NamingHelperTest.DefaultCharset.set
    test.jvmArgs( ['--add-opens', 'java.base/java.nio.charset=ALL-UNNAMED'] )
    // Weld needs this to generate proxies
    test.jvmArgs( ['--add-opens', 'java.base/java.security=ALL-UNNAMED'] )
    test.jvmArgs( ['--add-opens', 'java.base/java.lang=ALL-UNNAMED'] )

    test.beforeTest { descriptor ->
        //println "Starting test: " + descriptor
    }

    // Allow to exclude specific tests
    if (project.hasProperty('excludeTests')) {
        test.filter {
            excludeTestsMatching project.property('excludeTests').toString()
        }
    }
    else {
        String[] testsToIgnore = SkipTests.processSkipTests(test.filter, projectDir);

        test.filter {

            if (testsToIgnore) {
                println("Telling gradle to exclude ${testsToIgnore.length} tests");
                //setExcludePatterns(testsToIgnore);

                for (String fqTestName: testsToIgnore)
                    excludeTestsMatching "${fqTestName}";

                //println("EXCLUDE: " + excludePatterns.contains("org.hibernate.orm.test.annotations.SecuredBindingTest.testConfigurationMethods"));
                //println("EXCLUDE: " + excludePatterns.contains("org.hibernate.orm.test.annotations.cid.CompositeIdTest.testGetWithDetachedEntityInCompositeIDWithManagedCopy"));
            }

            //excludeTestsMatching "org.hibernate.orm.test.annotations.cid.CompositeIdTest"
            //excludeTestsMatching "org.hibernate.orm.test.annotations.SecuredBindingTest.testConfigurationMethods"
            //excludeTestsMatching "org.hibernate.orm.test.type.VarbinaryArrayTest"
            println("Gradle claims it will ignore ${excludePatterns.size()} tests")
        }
    }
}

class SkipTests {
    static String SKIP_TESTS_FILE_NAME = "skip-tests.txt";
    static boolean PROCESS_SKIP_TESTS = true;
    static String[] testsToIgnore;

    public static String[] processSkipTests(var testFilter, File projectDir) {
        if (!PROCESS_SKIP_TESTS)
            return testsToIgnore;

        File skipTests = new File(projectDir, SKIP_TESTS_FILE_NAME);
        println("Processing ${skipTests.absoluteFile}, filter is a " + testFilter.class)
        PROCESS_SKIP_TESTS = false;
        List<String> testsToIgnore = new ArrayList<>();

        if (skipTests.exists()) {
            List lines = java.nio.file.Files.readAllLines(skipTests.toPath());
            println("Lines = ${lines.size}")
            int testCount = 0;

            for (String line: lines) {
                line = line.trim();

                if (line.length() == 0 || line.charAt(0) == '#')
                    continue
                else {
                    int ix = line.indexOf('(');

                    if (ix != -1)
                        line = line.substring(0,ix).trim();

                    if (line.contains("CompositeIdTest"))
                        println("excluding [${line}]");

                    // Exclude this test
                    testsToIgnore.add(line);
                    testCount++;
                }
            }

            println("Excluding ${testCount} tests");
        }

        return this.testsToIgnore = testsToIgnore.toArray();
    }
}
