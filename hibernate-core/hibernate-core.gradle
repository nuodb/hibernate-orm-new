/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later.
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
import org.apache.tools.ant.filters.ReplaceTokens
import java.io.File

plugins {
    id 'org.hibernate.build.xjc-jakarta'
}

description = 'Hibernate\'s core ORM functionality'

apply from: rootProject.file( 'gradle/published-java-module.gradle' )
apply plugin: 'org.hibernate.orm.antlr'
apply plugin: 'org.hibernate.matrix-test'


// BEGIN: For NUODB
println "hibernate-core: Using NuoDB Dialect V${nuodbHibernateJarVersion}"
// END: For NUODB

configurations {
    tests {
        description = 'Configuration for the produced test jar'
    }
}

// BEGIN: For NUODB
// Look for our JAR locally
repositories {
    mavenCentral()
    mavenLocal()
}
// END: For NUODB

dependencies {
    api jakartaLibs.jpa
    api jakartaLibs.jta

    implementation libs.hcann
    implementation libs.jandex
    implementation libs.classmate
    implementation libs.byteBuddy

    implementation jakartaLibs.jaxbApi
    implementation jakartaLibs.jaxb
    implementation jakartaLibs.inject

    implementation libs.antlrRuntime

    compileOnly jakartaLibs.jacc
    compileOnly jakartaLibs.validation
    compileOnly jakartaLibs.cdi
    compileOnly jakartaLibs.jsonbApi
    compileOnly libs.jackson
    compileOnly libs.jacksonXml

    testImplementation project(':hibernate-testing')
    testImplementation project(':hibernate-ant')
    testImplementation testLibs.shrinkwrapApi
    testImplementation testLibs.shrinkwrap
    testImplementation testLibs.shrinkwrapDescriptors
    testImplementation testLibs.shrinkwrapDescriptorsApi
    testImplementation jakartaLibs.cdi
    testImplementation jakartaLibs.jacc
    testImplementation jakartaLibs.validation
    testImplementation jakartaLibs.el
    testImplementation( libs.validator ) {
        // for test runtime
        transitive = true
    }
    testImplementation "joda-time:joda-time:2.3"

    testImplementation    'com.nuodb.jdbc:nuodb-jdbc:24.1.1'
    testImplementation    "com.nuodb.hibernate:nuodb-hibernate:${nuodbHibernateJarVersion}"
    testImplementation group: 'org.slf4j', name: 'slf4j-api', version: '2.0.9'
    testImplementation group: 'ch.qos.logback', name: 'logback-core', version: '1.4.11'

    testRuntimeOnly libs.byteBuddy
    testRuntimeOnly testLibs.weld
    testRuntimeOnly testLibs.wildFlyTxnClient
    testRuntimeOnly libs.jackson

    testAnnotationProcessor project( ':hibernate-jpamodelgen' )

    // NOTE: it seems like, since 4.10, the Antlr Tool no longer defines
    // transitive dep on the corresponding Antlr Runtime.  At least, I get
    // errors about mismatched versions if I do not include the runtime
    // dependency here.
    antlr libs.antlr
    antlr libs.antlrRuntime

    xjc jakartaLibs.xjc
    xjc jakartaLibs.jaxb
    xjc rootProject.fileTree(dir: 'patched-libs/jaxb2-basics', include: '*.jar')
}

jar {
    manifest {
        attributes(
                'Main-Class': 'org.hibernate.Version'
        )
    }
}

ext {
    jaxbTargetDir = project.file( "${buildDir}/generated/sources/xjc/main" )
}

sourceSets {
    main {
        // add the XJC generated JAXB classes to the main source-set
        java{
            srcDir project.jaxbTargetDir
        }
    }

    // resources inherently exclude sources
    test {
        resources {
            srcDir 'src/test/java'
            srcDir 'src/test/resources'
            srcDir 'src/test/bundles'
        }
    }
}

xjc {
    outputDirectory = project.jaxbTargetDir

    schemas {
        cfg {
            xsdFile = 'src/main/resources/org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd'
            xjcBindingFile = 'src/main/xjb/hbm-configuration-bindings.xjb'
        }
        hbm {
            xsdFile = file( 'src/main/resources/org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd' )
            xjcBindingFile = file( 'src/main/xjb/hbm-mapping-bindings.xjb' )
            xjcExtensions += ['inheritance', 'simplify']
        }
        mapping {
            xsdFile = file( 'src/main/resources/org/hibernate/xsd/mapping/mapping-3.1.0.xsd' )
            xjcBindingFile = file( 'src/main/xjb/mapping-bindings.xjb' )
            xjcExtensions += ['inheritance', 'simplify']
        }
    }
}

task copyBundleResourcesXml (type: Copy) {
    inputs.property( "db", db )
    inputs.property( "dbHost", dbHost )
    ext {
        bundlesTargetDir = file( "${buildDir}/bundles" )
        // Escape
        bundleTokens = [
                'db.dialect' : dbBundle[db]['db.dialect'].replace("&", "&amp;"),
                'jdbc.driver' : dbBundle[db]['jdbc.driver'].replace("&", "&amp;"),
                'jdbc.user' : dbBundle[db]['jdbc.user'].replace("&", "&amp;"),
                'jdbc.pass' : dbBundle[db]['jdbc.pass'].replace("&", "&amp;"),
                'jdbc.url' : dbBundle[db]['jdbc.url'].replace("&", "&amp;"),
                'connection.init_sql' : dbBundle[db]['connection.init_sql'].replace("&", "&amp;")
        ]
        ext.bundleTokens['buildDirName'] = project.relativePath( buildDir )
    }

    from('src/test/bundles/templates') {
        include '**/*.xml'
    }
    into ext.bundlesTargetDir
    filter( ReplaceTokens, tokens: ext.bundleTokens)

    doFirst {
        ext.bundlesTargetDir.mkdirs()
    }
}

task copyBundleResourcesNonXml (type: Copy) {
    inputs.property( "db", db )
    ext {
        bundlesTargetDir = file( "${buildDir}/bundles" )
        // Escape
        bundleTokens = dbBundle[db]
        ext.bundleTokens['buildDirName'] = project.relativePath( buildDir )
    }

    from('src/test/bundles/templates') {
        exclude '**/*.xml'
    }
    into ext.bundlesTargetDir
    filter( ReplaceTokens, tokens: ext.bundleTokens)

    doFirst {
        ext.bundlesTargetDir.mkdirs()
    }
}

task copyBundleResources (type: Copy) {
    inputs.property( "db", db )
    dependsOn tasks.copyBundleResourcesXml
    dependsOn tasks.copyBundleResourcesNonXml
}

processTestResources {
    dependsOn copyBundleResources
    // NuoDB: 2 Feb 2024: do we care about duplicates? Commenting out for now.
    //duplicatesStrategy = DuplicatesStrategy.WARN
}

sourcesJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

}

task testJar(type: Jar, dependsOn: testClasses) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveClassifier.set( 'test' )
    from sourceSets.test.output
}

artifacts {
    tests testJar
}

task generateEnversStaticMetamodel(
        type: JavaCompile,
        description: "Generate the Hibernate Envers revision entity static metamodel classes." ) {
    source = sourceSets.main.java
    // we only want to include these specific classes for metamodel generation.
    // if envers adds any additional revision entity classes, they must be listed here.
    include 'org/hibernate/envers/DefaultRevisionEntity.java'
    include 'org/hibernate/envers/DefaultTrackingModifiedEntitiesRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdRevisionEntity.java'
    include 'org/hibernate/envers/enhanced/SequenceIdTrackingModifiedEntitiesRevisionEntity.java'

    classpath = sourceSets.main.runtimeClasspath + sourceSets.test.compileClasspath
    options.compilerArgs = [
            "-proc:only",
            "-processor",
            "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor"
    ]

    // put static metamodel classes back out to the source tree since they're version controlled.
    destinationDirectory = new File( "${projectDir}/src/main/java" )
}

tasks.withType( Test.class ).each { test ->
    test.systemProperty 'file.encoding', 'utf-8'

    // See org.hibernate.boot.model.naming.NamingHelperTest.DefaultCharset.set
    test.jvmArgs( ['--add-opens', 'java.base/java.nio.charset=ALL-UNNAMED'] )
    // Weld needs this to generate proxies
    test.jvmArgs( ['--add-opens', 'java.base/java.security=ALL-UNNAMED'] )
    test.jvmArgs( ['--add-opens', 'java.base/java.lang=ALL-UNNAMED'] )

    test.beforeTest { descriptor ->
        //println "Starting test: " + descriptor
    }

    // Allow to exclude specific tests - don't use this if you are using skip-tests.txt or green-list.txt
    if (project.hasProperty('excludeTests')) {
        test.filter {
            excludeTestsMatching project.property('excludeTests').toString()
        }
    }
}

/**
 * Check for skip-tests.txt or green-list.txt. This is done in the Java code, so
 * this class is no logner used. Leaving for now, in case it is needed again.
 */
class TestsChecker {
    public final static String GREEN_TESTS_FILE_NAME = "green-list.txt";
    public final static String SKIP_TESTS_FILE_NAME = "skip-tests.txt";

    public static boolean PROCESS_SKIP_TESTS = true;
    public static boolean PROCESS_GREEN_TESTS = true;
    public static String[] testsToRun;
    public static String[] testsToIgnore;

    public static hasGreenTestsToRun() {
        return testsToRun != null && testsToRun.length > 0;
    }

    public static hasTestsToIgnore() {
        return testsToIgnore != null && testsToIgnore.length > 0;
    }

    public static void checkForTests(File projectDir) {
        processGreenTests(projectDir);
        processSkipTests(projectDir);
    }

    private static String[] processGreenTests(File projectDir) {
        if (!PROCESS_GREEN_TESTS)
            return testsToIgnore;

        File greenTests = new File(projectDir, GREEN_TESTS_FILE_NAME);
        println("Processing ${greenTests.absoluteFile}");
        PROCESS_GREEN_TESTS = false;
        List<String> testsToRun = new ArrayList<>();

        if (greenTests.exists()) {
            List lines = java.nio.file.Files.readAllLines(greenTests.toPath());
            println(GREEN_TESTS_FILE_NAME + ": lines = ${lines.size}")
            int testCount = 0;

            for (String line: lines) {
                line = line.trim();

                if (line.length() == 0 || line.charAt(0) == '#')
                    continue
                else {
                    int ix = line.indexOf('(');

                    if (ix != -1)
                        line = line.substring(0,ix).trim();

                    if (line.contains("CompositeIdTest"))
                        println("Running [${line}]");

                    // Run this test
                    testsToRun.add(line);
                    testCount++;
                }
            }

            println("Running ${testCount} tests");
        }

        return this.testsToRun = testsToRun.toArray();
    }

    private static String[] processSkipTests(File projectDir) {
        if (!PROCESS_SKIP_TESTS)
            return testsToIgnore;

        if (hasGreenTestsToRun())
            return testsToIgnore = new String[0];   // Ignoring everything except green tests

        File skipTests = new File(projectDir, SKIP_TESTS_FILE_NAME);
        println("Processing ${skipTests.absoluteFile}");
        PROCESS_SKIP_TESTS = false;
        List<String> testsToIgnore = new ArrayList<>();

        if (skipTests.exists()) {
            List lines = java.nio.file.Files.readAllLines(skipTests.toPath());
            println(SKIP_TESTS_FILE_NAME + ": lines = ${lines.size}")
            int testCount = 0;

            for (String line: lines) {
                line = line.trim();

                if (line.length() == 0 || line.charAt(0) == '#')
                    continue
                else {
                    int ix = line.indexOf('(');

                    if (ix != -1)
                        line = line.substring(0,ix).trim();

                    if (line.contains("CompositeIdTest"))
                        println("excluding [${line}]");

                    // Exclude this test
                    testsToIgnore.add(line);
                    testCount++;
                }
            }

            println("Excluding ${testCount} tests");
        }

        return this.testsToIgnore = testsToIgnore.toArray();
    }
}
